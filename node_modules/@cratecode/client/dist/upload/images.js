"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadImages = void 0;
const axios_1 = __importDefault(require("axios"));
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const form_data_1 = __importDefault(require("form-data"));
const image_size_1 = require("image-size");
/**
 * Uploads all the images stored in a directory
 * and returns the mapping of all of those
 * images to their corresponding IDs.
 * @param state - is the current state of the application.
 * @param path - a case-sensitive map of image name to ID.
 */
function uploadImages(state, path) {
    return __awaiter(this, void 0, void 0, function* () {
        // Query the API to avoid re-uploading
        // files that have the same hash and extension.
        // Any files that have already been uploaded will go
        // into the output, and any files that haven't
        // will be uploaded, then put into the output.
        const uploadedList = (yield axios_1.default.get(`https://cratecode.com/internal/api/file/list`, {
            headers: { authorization: state.key },
        })).data;
        const filesNames = yield fs_1.default.promises.readdir(path);
        const output = {};
        for (const fileName of filesNames) {
            const filePath = path_1.default.join(path, fileName);
            const format = path_1.default.extname(fileName).slice(1);
            const hash = yield getFileHash(filePath);
            const { width, height } = (0, image_size_1.imageSize)(yield fs_1.default.promises.readFile(filePath));
            const uploadedFile = uploadedList.find((file) => file.format === format && file.hash === hash);
            if (!uploadedFile) {
                // File with same hash and format not found, upload it
                const formData = new form_data_1.default();
                formData.append("file", fs_1.default.createReadStream(filePath));
                const uploadResult = yield axios_1.default.put(`https://cratecode.com/internal/api/file/image/upload/${format}`, formData, {
                    headers: Object.assign(Object.assign({}, formData.getHeaders()), { authorization: state.key }),
                });
                output[fileName] = {
                    id: uploadResult.data.id,
                    format,
                    width,
                    height,
                };
                console.log(`Uploaded Image "${filePath}".`);
            }
            else {
                output[fileName] = { id: uploadedFile.id, format, width, height };
                console.log(`Verified Image "${filePath}".`);
            }
        }
        return output;
    });
}
exports.uploadImages = uploadImages;
/**
 * Returns the sha256 hash of the given file,
 * formatted to the format the Cratecode uses.
 * @param path - is the path of the file to read.
 */
function getFileHash(path) {
    return __awaiter(this, void 0, void 0, function* () {
        return crypto_1.default
            .createHash("sha256")
            .update(yield fs_1.default.promises.readFile(path))
            .digest("hex")
            .substring(0, 16);
    });
}
//# sourceMappingURL=images.js.map