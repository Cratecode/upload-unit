"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.delay = exports.sleep = exports.upload = void 0;
const manifest_1 = require("./manifest");
const lesson_1 = require("./lesson");
const axios_1 = __importDefault(require("axios"));
/**
 * Uploads a project to Cratecode.
 * @param manifest {string} - is a path to the manifest file.
 * @param key {string} - is the API key used to upload items.
 */
function upload(manifest, key) {
    return __awaiter(this, void 0, void 0, function* () {
        // When we hit a 429 (ratelimit), we'll wait 1 minute and retry.
        axios_1.default.interceptors.response.use((res) => res, (error) => {
            var _a;
            if ((error === null || error === void 0 ? void 0 : error.config) && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 429) {
                // Axios will double stringify if we don't do this.
                try {
                    if (error.config.data) {
                        error.config.data = JSON.parse(error.config.data);
                    }
                }
                catch (_) {
                    // This will trigger if data wasn't actually JSON (which is fine).
                }
                return sleep(60 * 1000).then(() => axios_1.default.request(error.config));
            }
            return Promise.reject(error);
        });
        const state = {
            itemCount: { value: 0 },
            idsMap: {},
            key,
            templates: null,
            configTemplate: null,
        };
        // Open the initial manifest.
        yield (0, manifest_1.readManifest)(state, null, manifest);
        // Now, we should clean up websockets. If all websockets are closed, we can safely exit
        // the program, otherwise we should wait 30 seconds, then force close them and force exit after 5 seconds.
        if (lesson_1.websockets.some((ws) => ws.readyState !== ws.CLOSED)) {
            setTimeout(() => {
                for (const ws of lesson_1.websockets) {
                    if (ws.readyState !== ws.CLOSED) {
                        ws.close();
                    }
                }
                setTimeout(() => {
                    process.exit(0);
                }, 5000);
            }, 30 * 1000);
        }
    });
}
exports.upload = upload;
/**
 * Sleeps for a delay.
 * @param ms {number} - is the amount of time to sleep for.
 */
function sleep(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
exports.sleep = sleep;
/**
 * Delays if the ratelimit has been hit.
 * @param state {State} - is the state.
 */
function delay(state) {
    return __awaiter(this, void 0, void 0, function* () {
        if (++state.itemCount.value % 50 === 0) {
            console.log("Hit ratelimit, sleeping.");
            yield sleep(60 * 1000);
            console.log("Waking up.");
        }
    });
}
exports.delay = delay;
//# sourceMappingURL=index.js.map