"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readManifest = void 0;
const index_1 = require("./index");
const fs = __importStar(require("fs"));
const unit_1 = require("./unit");
const Path = __importStar(require("path"));
const lesson_1 = require("./lesson");
/**
 * Reads and handles a manifest file.
 * @param state {State} - is the state of the application.
 * @param parent {string | null} - is the manifest that referenced this manifest.
 * @param templates {string | null} - is the path to the templates.
 * @param manifest {string} - is the manifest to read.
 */
function readManifest(state, parent, templates, manifest) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const data = JSON.parse(yield fs.promises.readFile(manifest, "utf-8"));
            if (typeof data !== "object" || Array.isArray(data))
                throw new Error("Manifest must be an object!");
            const newBase = Path.dirname(manifest);
            // Handle new templates.
            if (data["templates"]) {
                if (typeof data["templates"] !== "string")
                    throw new Error("Templates must be a string!");
                templates = Path.join(newBase, data["templates"]);
            }
            // Read and handle other referenced manifests.
            if (data["upload"]) {
                if (typeof data !== "object" || !Array.isArray(data["upload"]))
                    throw new Error("Upload must be an array!");
                for (const item of data["upload"]) {
                    if (typeof item !== "string")
                        throw new Error("Upload must be a string array!");
                    yield readManifest(state, manifest, templates, Path.join(newBase, item, "manifest.json"));
                }
            }
            // Figure out which type of manifest this is.
            // If no type is defined, it's probably only being
            // used for uploading, so we can ignore it.
            if (!data["type"])
                return;
            switch (data["type"]) {
                case "unit": {
                    const id = data["id"];
                    const name = data["name"];
                    const lessons = data["lessons"];
                    if (typeof id !== "string")
                        throw new Error("id must be a string!");
                    if (typeof name !== "string")
                        throw new Error("name must be a string!");
                    if (typeof lessons !== "object" || Array.isArray(lessons))
                        throw new Error("lessons must be an object!");
                    const unitID = yield (0, unit_1.handleUnit)(state, id, name, lessons);
                    console.log(`Uploaded Unit "${manifest}" (ID: "${unitID}").`);
                    break;
                }
                case "lesson": {
                    const id = data["id"];
                    const name = data["name"];
                    const unit = data["unit"];
                    const spec = data["spec"];
                    const extends1 = data["extends"];
                    const lessonClass = data["class"];
                    if (typeof id !== "string")
                        throw new Error("id must be a string!");
                    if (typeof name !== "string")
                        throw new Error("name must be a string!");
                    // Unit must be explicitly defined as null.
                    if (typeof unit !== "string" && unit !== null)
                        throw new Error("unit must be a string or null!");
                    // Spec must be explicitly defined as null.
                    if (typeof spec !== "string" && spec !== null)
                        throw new Error("spec must be a string or null!");
                    // Extends must be a string or null, and if it isn't null, templates must be defined.
                    if (typeof extends1 !== "string" && extends1 != null)
                        throw new Error("extends must be a string or null!");
                    if (typeof extends1 === "string" && templates == null)
                        throw new Error("extends must be used with templates!");
                    // Class must be explicitly defined as null.
                    // If it isn't, it must be a certain value.
                    const classMap = {
                        // null: 0
                        tutorial: 1,
                        activity: 2,
                        project: 3,
                        challenge: 4,
                    };
                    if (!(lessonClass in classMap) && lessonClass !== null)
                        throw new Error("class must be null or one of [" +
                            Object.keys(classMap).join(", ") +
                            "]!");
                    const lessonID = yield (0, lesson_1.handleLesson)(state, id, name, unit, spec, extends1 ? Path.join(templates, extends1) : null, classMap[lessonClass] || 0, Path.dirname(manifest));
                    console.log(`Uploaded Lesson "${manifest}" (ID: "${lessonID}").`);
                    break;
                }
                default: {
                    throw new Error('Type must be either undefined, "unit", or "lesson".');
                }
            }
            // Handle delays.
            yield (0, index_1.delay)(state);
        }
        catch (e) {
            if (parent) {
                console.error(`An error occurred while reading ${manifest} (called by ${parent}):`);
            }
            else {
                console.error(`An error occurred while reading ${manifest}:`);
            }
            throw e;
        }
    });
}
exports.readManifest = readManifest;
//# sourceMappingURL=manifest.js.map