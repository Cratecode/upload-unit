"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readManifest = void 0;
const index_1 = require("./index");
const fs = __importStar(require("fs"));
const unit_1 = require("./unit");
const Path = __importStar(require("path"));
const lesson_1 = require("./lesson");
const images_1 = require("./images");
/**
 * Reads and handles a manifest file.
 * @param state {State} - is the state of the application.
 * This object MUST be unique to this method. However, the items it contains
 * may not be.
 * @param parent {string | null} - is the manifest that referenced this manifest.
 * @param manifest {string} - is the manifest to read.
 */
function readManifest(state, parent, manifest) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const data = JSON.parse(yield fs.promises.readFile(manifest, "utf-8"));
            if (typeof data !== "object" || Array.isArray(data)) {
                throw new Error("Manifest must be an object!");
            }
            const newBase = Path.dirname(manifest);
            // Handle new templates.
            if (data["templates"]) {
                if (typeof data["templates"] !== "string") {
                    throw new Error("Templates must be a string!");
                }
                state.templates = Path.join(newBase, data["templates"]);
            }
            // Handle new images.
            if (data["images"]) {
                if (typeof data["images"] !== "string") {
                    throw new Error("Images must be a string!");
                }
                const imagesDir = Path.join(newBase, data["images"]);
                state.images = yield (0, images_1.uploadImages)(state, imagesDir);
            }
            // Handle new config template.
            if (data["configTemplate"]) {
                if (typeof data["configTemplate"] !== "object" &&
                    !Array.isArray(data["configTemplate"])) {
                    throw new Error("Config Template must be an object!");
                }
                state.configTemplate = data["configTemplate"];
            }
            // Read and handle other referenced manifests.
            if (data["upload"]) {
                if (typeof data !== "object" || !Array.isArray(data["upload"])) {
                    throw new Error("Upload must be an array!");
                }
                for (const item of data["upload"]) {
                    if (typeof item !== "string") {
                        throw new Error("Upload must be a string array!");
                    }
                    yield readManifest(Object.assign({}, state), manifest, Path.join(newBase, item, "manifest.json"));
                }
            }
            // Figure out which type of manifest this is.
            // If no type is defined, it's probably only being
            // used for uploading, so we can ignore it.
            if (!data["type"])
                return;
            switch (data["type"]) {
                case "unit": {
                    const id = data["id"];
                    const name = data["name"];
                    const lessons = data["lessons"];
                    if (typeof id !== "string") {
                        throw new Error("id must be a string!");
                    }
                    if (typeof name !== "string") {
                        throw new Error("name must be a string!");
                    }
                    if (typeof lessons !== "object" || Array.isArray(lessons)) {
                        throw new Error("lessons must be an object!");
                    }
                    const unitID = yield (0, unit_1.handleUnit)(Object.assign({}, state), id, name, lessons);
                    console.log(`Uploaded Unit "${manifest}" (ID: "${unitID}").`);
                    break;
                }
                case "lesson": {
                    const id = data["id"];
                    const name = data["name"];
                    const description = data["description"];
                    const unit = data["unit"];
                    const spec = data["spec"];
                    const extendsTemplate = data["extends"];
                    const lessonClass = data["class"];
                    if (typeof id !== "string") {
                        throw new Error("id must be a string!");
                    }
                    if (typeof name !== "string") {
                        throw new Error("name must be a string!");
                    }
                    if (typeof description != "string" && description != null) {
                        throw new Error("description must be a string or null!");
                    }
                    if (typeof unit !== "string" && unit != null) {
                        throw new Error("unit must be a string or null!");
                    }
                    if (typeof spec !== "string" && spec != null) {
                        throw new Error("spec must be a string or null!");
                    }
                    // Extends must be a string or null, and if it isn't null, templates must be defined.
                    if (typeof extendsTemplate !== "string" &&
                        extendsTemplate != null) {
                        throw new Error("extends must be a string or null!");
                    }
                    if (typeof extendsTemplate === "string" &&
                        state.templates == null) {
                        throw new Error("extends must be used with templates!");
                    }
                    // Class must be null or one of the below values.
                    const classMap = {
                        // null: 0
                        tutorial: 1,
                        activity: 2,
                        project: 3,
                        challenge: 4,
                    };
                    if (!(lessonClass in classMap) && lessonClass != null) {
                        throw new Error("class must be null or one of [" +
                            Object.keys(classMap).join(", ") +
                            "]!");
                    }
                    const lessonID = yield (0, lesson_1.handleLesson)(Object.assign({}, state), id, name, description, unit, spec, extendsTemplate, classMap[lessonClass] || 0, Path.dirname(manifest));
                    console.log(`Uploaded Lesson "${manifest}" (ID: "${lessonID}").`);
                    break;
                }
                default: {
                    throw new Error('Type must be either undefined, "unit", or "lesson".');
                }
            }
            // Handle delays.
            yield (0, index_1.delay)(state);
        }
        catch (e) {
            if (parent) {
                console.error(`An error occurred while reading ${manifest} (called by ${parent}):`);
            }
            else {
                console.error(`An error occurred while reading ${manifest}:`);
            }
            throw e;
        }
    });
}
exports.readManifest = readManifest;
//# sourceMappingURL=manifest.js.map