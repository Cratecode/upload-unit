import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Main
 */
export interface Main {
    /**
     * @generated from protobuf field: MessageType type = 1;
     */
    type: MessageType;
    /**
     * @generated from protobuf field: optional bytes value = 2;
     */
    value?: Uint8Array;
}
/**
 * @generated from protobuf enum MessageType
 */
export declare enum MessageType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: Initialized = 1;
     */
    Initialized = 1,
    /**
     * @generated from protobuf enum value: NotInitialized = 2;
     */
    NotInitialized = 2,
    /**
     * @generated from protobuf enum value: Files = 3;
     */
    Files = 3,
    /**
     * @generated from protobuf enum value: Stopped = 4;
     */
    Stopped = 4,
    /**
     * @generated from protobuf enum value: ClientFile = 5;
     */
    ClientFile = 5
}
declare class Main$Type extends MessageType$<Main> {
    constructor();
    create(value?: PartialMessage<Main>): Main;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Main): Main;
    internalBinaryWrite(message: Main, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message Main
 */
export declare const Main: Main$Type;
export {};
